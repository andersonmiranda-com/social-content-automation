## 🧪 Chains and Pipelines

- Each `Chain` must be a reusable, testable, and decoupled unit.
- Each `Pipeline` must chain `Chains` using `RunnableSequence` or `RunnableMap`.
- Use `RunnableLambda` to adapt pure functions.
- You can have chains without AI (e.g., validators, formatters, adapters).

---

## 🧾 Configuration Management

- Each `Chain` or `Pipeline` can have a YAML file in `config/` with its parameters.
- Use functions like `load_config("generate_text")` to access them.
- Sensitive variables (keys, tokens, secrets) must go in `.env`, and `.env.example` must be kept up to date.

---

## 💾 Dependency and Environment

- Use `pipenv` for dependency management (`Pipfile`, `Pipfile.lock`).
- Never include `.env` in the repository. Use `.env.example`.
- Use `python-dotenv` or `pydantic` to validate and load environment variables.

---

## 🧪 Testing

- Every chain and pipeline must have at least one unit test (`tests/`).
- Use `pytest` + `mypy` + `black` + `isort` as base tools.
- It is recommended to configure GitHub Actions to run tests and linters automatically.

---

## 🧠 Code Style

- Follow PEP8 + `black`.
- Import in the order: stdlib → third-party → local.
- Use `type hints` and docstrings.
- Every Python file must have a module docstring.

---

## 🔁 Version Control

- Follow Conventional Commits.
- Use branch types:
  - `feat/`, `fix/`, `refactor/`, `docs/`
- Avoid direct commits to `main`.

---

## 🔥 Final Call

Think of each block as a Lego piece: simple, reusable, and without unnecessary couplings.
